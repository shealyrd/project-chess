enum State{

    WHITES_TURN,
    BLACKS_TURN,
    FINISH

}class StaticColors{
    static BASIC_BOARD_WHITE = "#f0d9b5";
    static BASIC_BOARD_BLACK = "#b58863";
    static SQUARE_SELECTION_BLUE = "#7294da";
    static SQUARE_SELECTION_RED = "#e60000";
}class Algorithms{
    static shuffle (array) {
    var i = 0
        , j = 0
        , temp = null

    for (i = array.length - 1; i > 0; i -= 1) {
        j = Math.floor(Math.random() * (i + 1))
        temp = array[i]
        array[i] = array[j]
        array[j] = temp
    }
}
}class CallbackPool{
    private callbacks: {(): void;}[] = [];
    
    constructor(...callbacks: {(): void;}[]){
        this.callbacks = callbacks;
    }
   
    public addCallback(callback: {(): void;}): CallbackPool{
        this.callbacks.push(callback);
        return this;
    }
    
    public fire(): void{
        for(var i = 0; i < this.callbacks.length; i++){
            this.callbacks[i]();
        }
    }
    
    public reset(): void{
        this.callbacks = [];
    }
}class IDSequence{
    static count: number = 0;

    static nextVal(): number{
        IDSequence.count = IDSequence.count + 1;
        return IDSequence.count;
    }
}abstract class HTMLObject {
    topPos: number;
    leftPos: number;
    height: number;
    width: number;
    id: string = IDSequence.nextVal() + "";

    setTopPos(input: number): void{
        this.topPos = input;
    }

    setLeftPos(input: number): void{
        this.leftPos = input;
    }

    setHeight(input: number): void{
        this.height = input;
    }

    setWidth(input: number): void{
        this.width = input;
    }

    getTopPos(): number{
        return this.topPos;
    }

    getLeftPos(): number{
        return this.leftPos;
    }

    getId(): string{
        return this.id;
    }

    setId(id: string){
       this.id = id;
    }

    getHeight(): number{
        return this.height;
    }

    getWidth(): number{
        return this.width;
    }

    abstract toHTML(): string;
}class HTMLBuilder{

    styles = {};
    classes: string[] = new Array();
	innerDivs: string[] = new Array();
    base: string = "<div {info-template}>{inner}</div>";
    id: string;



    newDiv(): HTMLBuilder{
        return this;
    }

    setId(id: string): HTMLBuilder{
        this.id = id;
        return this;
    }

    addStyle(type: string, value: string): HTMLBuilder{
        this.styles[type] = value;
        return this;
    }

    addClass(classname: string): HTMLBuilder{
        this.classes.push(classname);
        return this;
    }
	
	addInnerDiv(innerDiv: string): HTMLBuilder{
        this.innerDivs.push(innerDiv);
        return this;
    }

    toString(): string{
        var result: string;
        var style: string;
        var idDef: string = "";
        var classDef: string;
		var innerDivDef: string = "";

        if(this.id != undefined){
            idDef = "id=\"" + this.id + "\"";
        }


        style = "style=\"";
        for(var each in this.styles){
            style = style + each + ": " + this.styles[each] + "; ";
        }
        style = style + "\"";

        classDef = "class=\"";
        for (var eachClass in this.classes) {
            classDef = classDef + this.classes[eachClass] + " ";
        }
        classDef = classDef + "\"";
		
		if(this.innerDivs.length > 0){
			for(var eachDiv in this.innerDivs){
				innerDivDef += this.innerDivs[eachDiv];
			}
		}

        result = this.base.replace("{info-template}", (idDef + " " + classDef + " " + style));
		result = result.replace("{inner}", innerDivDef);

        return result;
    }
}enum Color{
	WHITE,
	BLACK
}enum PieceType{

    PAWN = 1,
    KNIGHT = 2,
    BISHOP = 3,
    ROOK = 4,
    QUEEN = 5,
    KING = 6

}
class PieceLocation{
    x : number;
    y: number;
    type: PieceType;
    color: Color;

    constructor(x:number, y: number, type: PieceType, color: Color){
        this.x = x;
        this.y = y;
        this.type = type;
        this.color = color;
    }

    getX(): number{
        return this.x;
    }
    getY(): number{
        return this.y;
    }
    getType(): PieceType{
        return this.type;
    }
    getColor(): Color{
        return this.color;
    }
}
abstract class Piece extends HTMLObject{
    z: number;
	color: Color;
	x: number;
    y: number;

    constructor(left: number, top: number, width: number, height: number, z:number, color: Color){
        super();
        this.setTopPos(top);
        this.setLeftPos(left);
        this.setWidth(width);
        this.setHeight(height);
        this.setZ(z);
		this.setColor(color);
    }

    setZ(z: number) {
        this.z = z;
    }
	
    getZ(): number {
        return this.z;
    }

    setX(x:number){
      this.x = x;
    }
    getX(): number{
        return this.x;
    }

    setY(y:number){
        this.y = y;
    }

    getY(): number{
        return this.y;
    }
	
	abstract getWhiteImg(): string;
	abstract getBlackImg(): string;


	static getSizeRatio(): number{
        return 1;
    }
	
	setColor(color: Color){
		this.color = color;
	}
	
	getColor(): Color{
		return this.color;
	}
	
	toHTML():string {
        var builder: HTMLBuilder = new HTMLBuilder();
        builder.newDiv()
                .addClass("piece")
                .addStyle("position", "absolute")
                .addStyle("left", this.getLeftPos() + "")
                .addStyle("top", this.getTopPos() + "")
                .addStyle("width", this.getWidth() + "px")
                .addStyle("height", this.getHeight() + "px")
				.addStyle("z-index", this.getZ() + "")
				.addStyle("pointer-events", "none")
                .setId(this.getId());

				var contentImg: string;
				if(this.getColor() == Color.WHITE){
					contentImg = this.getWhiteImg();
				}
				else if(this.getColor() == Color.BLACK){
					contentImg = this.getBlackImg();
				}
				
				builder.addStyle("content", "url(" + contentImg + ")");
				
        return builder.toString();
    }

}
class Pawn extends Piece{
    static blackImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/bP.png";
    static whiteImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/wP.png";

    static getSizeRatio(): number{
        return 1.5;
    }

    getWhiteImg(): string{
        return Pawn.whiteImg;
    }

    getBlackImg(): string{
        return Pawn.blackImg;
    }

}class Bishop extends Piece{
    static blackImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/bB.png";
    static whiteImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/wB.png";

    static getSizeRatio(): number{
        return 1.5;
    }

    getWhiteImg(): string{
        return Bishop.whiteImg;
    }

    getBlackImg(): string{
        return Bishop.blackImg;
    }

}class King extends Piece{
    static blackImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/bK.png";
    static whiteImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/wK.png";

    static getSizeRatio(): number{
        return 1.5;
    }

    getWhiteImg(): string{
        return King.whiteImg;
    }

    getBlackImg(): string{
        return King.blackImg;
    }

}class Queen extends Piece{
	static blackImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/bQ.png";
	static whiteImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/wQ.png";

	static getSizeRatio(): number{
		return 1.5;
	}

	getWhiteImg(): string{
		return Queen.whiteImg;
	}

	getBlackImg(): string{
		return Queen.blackImg;
	}

}class Knight extends Piece{
    static blackImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/bN.png";
    static whiteImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/wN.png";

    static getSizeRatio(): number{
        return 1.5;
    }

    getWhiteImg(): string{
        return Knight.whiteImg;
    }

    getBlackImg(): string{
        return Knight.blackImg;
    }

}class Rook extends Piece{
	static blackImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/bR.png";
	static whiteImg: string = "http://chessboardjs.com/img/chesspieces/wikipedia/wR.png";

	static getSizeRatio(): number{
		return 1.5;
	}

	getWhiteImg(): string{
		return Rook.whiteImg;
	}

	getBlackImg(): string{
		return Rook.blackImg;
	}


}class Square extends HTMLObject{
	col: Color;
	x: number;
    y: number;
    hexColor: string;

    constructor(left: number, top: number, width: number, height: number){
        super();
        this.setTopPos(top);
        this.setLeftPos(left);
        this.setWidth(width);
        this.setHeight(height);
    }

    setX(x: number){
        this.x = x;
    }

    setY(y: number){
        this.y = y;
    }

    setHexColor(hex: string){
        this.hexColor = hex;
    }

    resetHexColor(){
       var hexColor: string;

        switch(this.col){
            case Color.WHITE: hexColor = "#f0d9b5"; break;
            case Color.BLACK: hexColor = "#b58863"; break;
        }

        this.setHexColor(hexColor);
    }

    getY(): number{
        return this.y;
    }

    getX(): number{
        return this.x;
    }

	setColor(newCol: Color){
		this.col = newCol;
        this.resetHexColor();
	}
	
	getColor(): Color{
		return this.col;
	}

    toHTML():string {
        var builder: HTMLBuilder = new HTMLBuilder();
        builder.newDiv()
                .addClass("square")
                .addStyle("position", "absolute")
                .addStyle("left", this.getLeftPos() + "")
                .addStyle("top", this.getTopPos() + "")
                .addStyle("width", this.getWidth() + "px")
                .addStyle("height", this.getHeight() + "px");

        builder.setId(this.getId());
        builder.addStyle("border", "1px solid black");
		builder.addStyle("background-color", this.hexColor);

        return builder.toString();
    }

} class Row extends HTMLObject{
    squares: Square[] = new Array();
	numSquares: number;
	y: number;
	
    constructor(left: number, top: number, width: number, height: number, sqrCount: number){
        super();
        this.setTopPos(top);
        this.setLeftPos(left);
        this.setWidth(width);
        this.setHeight(height);
		this.setNumSquares(sqrCount);

    }

	initialize(){
		for(var i: number = 0; i < this.getNumSquares(); i++){
			var newSquare: Square = new Square(this.getSquareLeftPos(i), 0, this.getSquareWidth(), this.getHeight());
			newSquare.setX(i);
			newSquare.setY(this.getY());
			newSquare.setId("square_" + i + "_" + this.getY());
			this.squares.push(newSquare);
		}
	}
	
	getSquares(): Square[]{
		return this.squares;
	}
	
	setY(y: number){
		this.y = y;
	}

	getY(): number{
		return this.y;
	}
	
	setNumSquares(sqrCount: number){
		this.numSquares = sqrCount;
	}
	
	getNumSquares(): number{
		return this.numSquares;
	}
	
	getSquareWidth(): number{
		return Math.ceil(this.getWidth() / this.numSquares);
	}
	
	getSquareLeftPos(index: number): number{
		return (index * this.getSquareWidth());
	}
	
	setAlternating(starting: Color){
		for(var each in this.squares){
			this.squares[each].setColor(starting);
			
			if(starting == Color.WHITE){
				starting = Color.BLACK;
			}
			else if(starting == Color.BLACK){
				starting = Color.WHITE;
			}
		}
	}

    toHTML():string {
		var builder: HTMLBuilder = new HTMLBuilder();
        builder.newDiv()
                .addClass("row")
                .addStyle("position", "absolute")
                .addStyle("left", this.getLeftPos() + "")
                .addStyle("top", this.getTopPos() + "")
                .addStyle("width", this.getWidth() + "px")
                .addStyle("height", this.getHeight() + "px");
        for(var each in this.squares) {
            builder.addInnerDiv(this.squares[each].toHTML());
        }
        return builder.toString();
    }


}class Board extends HTMLObject{
    squares: Square[] = new Array();
    rows: Row[] = new Array();
    pieces: Piece[] = new Array();

    locations: PieceLocation[] = new Array();

    numRows: number;
    numColumns: number;
    offsetTop: number;
    offsetLeft: number;

    squareWidth: number = 50;
    squareHeight: number = 50;



    constructor(numCol: number, numRows: number, offsetTop?: number, offsetLeft?: number) {
        super();
        if (offsetTop == null) {
            offsetTop = 100;
        }
        if (offsetLeft == null) {
            offsetLeft = 100;
        }
        this.initialize(numCol, numRows, offsetTop, offsetLeft);
    }

    initialize(numCol: number, numRows: number, offsetTop: number, offsetLeft: number){
        this.numRows = numRows;
        this.numColumns = numCol;
        this.offsetTop = offsetTop;
        this.offsetLeft = offsetLeft;

        var cornerColor: Color = Color.WHITE;

        for(var i: number = 0; i < this.numRows; i++){
            var row: Row = new Row(this.offsetLeft, this.offsetTop + (i * this.squareHeight), this.squareWidth * this.numColumns, this.squareHeight, this.numColumns);
            row.setY(i);
            row.initialize();
            row.setAlternating(cornerColor);
            this.rows.push(row);

            if(cornerColor == Color.WHITE){
                cornerColor = Color.BLACK;
            }
            else if(cornerColor == Color.BLACK){
                cornerColor = Color.WHITE;
            }
        }
    }

    getPieces(): Piece[]{
        return this.pieces;
    }
	
	getSquares(): Square[]{
		var result: Square[] = new Array();
		
		for(var row in this.rows){
			var each: Row = this.rows[row];
            var meSqrs = each.getSquares();
			for(var square in each.getSquares()){
                var eachSqr = meSqrs[square];
				result.push(eachSqr);
			}
		}
		
        return result;
    }

    addPiece(piece: PieceType, x: number, y: number, color: Color){
        var newPiece: Piece;
        switch(piece){
            case PieceType.ROOK: newPiece = new Rook(this.calcPosFromLeft(x), this.calcPosFromTop(Rook.getSizeRatio(), y), this.squareWidth, (this.squareHeight * Rook.getSizeRatio()), y, color); break;
            case PieceType.QUEEN: newPiece = new Queen(this.calcPosFromLeft(x), this.calcPosFromTop(Queen.getSizeRatio(), y), this.squareWidth, (this.squareHeight * Queen.getSizeRatio()), y, color); break;
            case PieceType.BISHOP: newPiece = new Bishop(this.calcPosFromLeft(x), this.calcPosFromTop(Bishop.getSizeRatio(), y), this.squareWidth, (this.squareHeight * Bishop.getSizeRatio()), y, color); break;
            case PieceType.PAWN: newPiece = new Pawn(this.calcPosFromLeft(x), this.calcPosFromTop(Pawn.getSizeRatio(), y), this.squareWidth, (this.squareHeight * Pawn.getSizeRatio()), y, color); break;
            case PieceType.KNIGHT: newPiece = new Knight(this.calcPosFromLeft(x), this.calcPosFromTop(Knight.getSizeRatio(), y), this.squareWidth, (this.squareHeight * Knight.getSizeRatio()), y, color); break;
            case PieceType.KING: newPiece = new King(this.calcPosFromLeft(x), this.calcPosFromTop(King.getSizeRatio(), y), this.squareWidth, (this.squareHeight * King.getSizeRatio()), y, color); break;
        }
        newPiece.setX(x);
        newPiece.setY(y);
        this.pieces.push(newPiece);
        this.addLocation(x, y, piece, color);
    }


    toHTML():string {
        var result: string = "";

        for (var row in this.rows) {
            result += this.rows[row].toHTML();
        }

        for (var piece in this.pieces) {
            result += this.pieces[piece].toHTML();
        }

        return result;
    }

    public setStandard(){
        this.addPiece(PieceType.ROOK, 0, 0, Color.BLACK);
        this.addPiece(PieceType.KNIGHT, 1, 0, Color.BLACK);
        this.addPiece(PieceType.BISHOP, 2, 0, Color.BLACK);
        this.addPiece(PieceType.QUEEN, 3, 0, Color.BLACK);
        this.addPiece(PieceType.KING, 4, 0, Color.BLACK);
        this.addPiece(PieceType.BISHOP, 5, 0, Color.BLACK);
        this.addPiece(PieceType.KNIGHT, 6, 0, Color.BLACK);
        this.addPiece(PieceType.ROOK, 7, 0, Color.BLACK);

        this.addPiece(PieceType.PAWN, 0, 1, Color.BLACK);
        this.addPiece(PieceType.PAWN, 1, 1, Color.BLACK);
        this.addPiece(PieceType.PAWN, 2, 1, Color.BLACK);
        this.addPiece(PieceType.PAWN, 3, 1, Color.BLACK);
        this.addPiece(PieceType.PAWN, 4, 1, Color.BLACK);
        this.addPiece(PieceType.PAWN, 5, 1, Color.BLACK);
        this.addPiece(PieceType.PAWN, 6, 1, Color.BLACK);
        this.addPiece(PieceType.PAWN, 7, 1, Color.BLACK);


        this.addPiece(PieceType.ROOK, 0, 7, Color.WHITE);
        this.addPiece(PieceType.KNIGHT, 1, 7, Color.WHITE);
        this.addPiece(PieceType.BISHOP, 2, 7, Color.WHITE);
        this.addPiece(PieceType.QUEEN, 3, 7, Color.WHITE);
        this.addPiece(PieceType.KING, 4, 7, Color.WHITE);
        this.addPiece(PieceType.BISHOP, 5, 7, Color.WHITE);
        this.addPiece(PieceType.KNIGHT, 6, 7, Color.WHITE);
        this.addPiece(PieceType.ROOK, 7, 7, Color.WHITE);

        this.addPiece(PieceType.PAWN, 0, 6, Color.WHITE);
        this.addPiece(PieceType.PAWN, 1, 6, Color.WHITE);
        this.addPiece(PieceType.PAWN, 2, 6, Color.WHITE);
        this.addPiece(PieceType.PAWN, 3, 6, Color.WHITE);
        this.addPiece(PieceType.PAWN, 4, 6, Color.WHITE);
        this.addPiece(PieceType.PAWN, 5, 6, Color.WHITE);
        this.addPiece(PieceType.PAWN, 6, 6, Color.WHITE);
        this.addPiece(PieceType.PAWN, 7, 6, Color.WHITE);
    }

    private addLocation(x: number, y: number, type: PieceType, color: Color){
        var newLocation = new PieceLocation(x, y, type, color);
        this.locations.push(newLocation);
    }

    private calcPosFromLeft(x:number): number{
        return this.offsetLeft + (x * this.squareWidth);
    }

    private calcPosFromTop(ratio: number, y:number): number{
        return (this.offsetTop + (y * this.squareHeight)) + (this.squareHeight * ( 1 - ratio));
    }

    public getPieceById(id: string): Piece{
        for(var piece in this.pieces){
            var each = this.pieces[piece];
            if(each.getId() == id){
                return each;
            }
        }
    }

	public getSquareById(id: string): Square{
		var locSquares = this.getSquares();
        for(var square in locSquares){
            var each = locSquares[square];
            if(each.getId() == id){
                return each;
            }
        }
    }
	
    public static fromSerial(serial: string): Board{
        var result: Board;
        var locations: PieceLocation[] = new Array();
        var length: number;
        var height: number;
        var rows: string[] = serial.split("/");
        height = rows.length;

        for(var y = 0; y < rows.length; y++){
            var row = rows[y];
            var squares: string[] = row.split(",");
            length = squares.length;

            for(var x = 0; x < squares.length; x++){
                var sqrData:string = squares[x].substring(1, squares[x].length - 1);

                if(sqrData.length != 0){
                    var sqrDataSplit = sqrData.split("_");
                    var thisColor: Color;

                    if(sqrDataSplit[1] == "W"){
                        thisColor = Color.WHITE;
                    }
                    else{
                        thisColor = Color.BLACK;
                    }
                    var newLoc: PieceLocation = new PieceLocation(x, y, +sqrDataSplit[0], thisColor);
                    locations.push(newLoc);
                }
            }
        }

        result = new Board(length, height);

        for(var eachLoc in locations){
            var location: PieceLocation = locations[eachLoc];
            result.addPiece(location.getType(), location.getX(), location.getY(), location.getColor());
        }

        return result;
    }

    public serialize(): string{
        var serialization: string = "";
        var pieceMap: string[][] = [];

        for(var r: number = 0; r < this.numRows; r++ ){
            pieceMap[r] = [];
        }

        for (var location in this.locations) {
            var currLoc = this.locations[location];
            var strRep = "[" + currLoc.getType() + "_";
            if(currLoc.getColor() == Color.WHITE){
                strRep += "W"
            }
            else if(currLoc.getColor() == Color.BLACK){
                strRep += "B"
            }
            strRep += "]";
            pieceMap[currLoc.getX()][currLoc.getY()] = strRep;
        }

        for(var y: number = 0; y < this.numRows; y++ ){
            for (var x: number = 0; x < this.numColumns; x++){
                if (pieceMap[x][y] == undefined) {
                    serialization += "[]";
                }
                else {
                    serialization += pieceMap[x][y];
                }
                serialization += ",";
            }
            serialization = serialization.substring(0, serialization.length - 1);
            serialization += "/";
        }
        serialization = serialization.substring(0, serialization.length - 1);
        return serialization;
    }

    unselectAllSquares(){
        var locSquares = this.getSquares();
        for(var square in locSquares){
            var each = locSquares[square];
            each.resetHexColor();
        }
    }

    getSquareAtPos(x:Number, y:Number): Square{
        var locSquares = this.getSquares();
        for(var square in locSquares){
            var each = locSquares[square];
            if(each.getX() == x && each.getY() == y){
                return each;
            }
        }
    }
}class Pos{
    private X: number;
    private Y: number;

    constructor(x: number, y: number){
        this.X = x;
        this.Y = y;
    }

    getX(): number{
        return this.X;
    }
    getY(): number{
        return this.Y;
    }

    toString(): string{
        return this.getX() + ", " + this.getY();
    }

    equals(pos: Pos): boolean{
        return (this.getX() == pos.getX()) && (this.getY() == pos.getY());
    }

}
class Move{
    private dest: Pos;
    private origin: Pos;

    constructor(origin: Pos, dest: Pos){
        this.dest = dest;
        this.origin = origin;
    }

    getDest(): Pos{
        return this.dest;
    }

    getOrigin(): Pos{
        return this.origin;
    }

    equals(move: Move): boolean{
        return this.getDest().equals(move.getDest()) && this.getOrigin().equals(move.getOrigin());
    }

}class MoveCollection{

    private moves: Move[] = new Array();

    constructor(moves?: Move[]){
        if(moves != null && moves != undefined){
            this.moves = moves;
        }
    }

    public add(move: Move){
        this.moves.push(move);
    }

    public getMoves(): Move[]{
        return this.moves;
    }

    public contains(move: Move): boolean{
        var result = false;
        this.moves.forEach((e, i, me) => {
            if(move.equals(e)){
                result = true;
            }
        });
        return result;
    }

    public addAll(movesArg: MoveCollection): MoveCollection{
        var moveArray: Move[] = movesArg.getMoves();
        moveArray.forEach((e, i, me) => {
            this.moves.push(e);
        });

        return this;
    }

    public minus(movesArg: MoveCollection): MoveCollection{
        var result: Move[] = new Array();
        var moveArray: Move[] = movesArg.getMoves();
        moveArray.forEach((e, i, me) => {
            this.moves.forEach((f, j, me2) => {
                if(!(f.getDest().equals(e.getDest()))) {
                        result.push(e);
                }
            });
        });
        this.moves = result;
        return this;
    }

    public containsDestination(pos: Pos){
        for(var moveIdx in this.getMoves()){
            var eachMove = this.moves[moveIdx];
            if(eachMove.getDest().equals(pos)){
                return true;
            }
        }
        return false;
    }

    public shuffle(){
        Algorithms.shuffle(this.moves);
    }
}class MoveFactory{

    static getAllUpwards(piece: PieceModel){
        var board: BoardModel = piece.getBoardModel();
        var result: Move[] = new Array();

        var x = piece.getPos().getX();
        var y = piece.getPos().getY() - 1;

        while(piece.getBoardModel().isValidPosition(new Pos(x, y))){
            if(!piece.getBoardModel().isFree(new Pos(x, y))){
                if(piece.getBoardModel().getPieceFromPosition(new Pos(x, y)).getColor() != piece.getColor()){
                    result.push(new Move(piece.getPos(), new Pos(x, y)));
                    break;
                }
                else{
                    break;
                }
            }
            result.push(new Move(piece.getPos(), new Pos(x, y)));
            y -= 1;
        }

        return new MoveCollection(result);
    }

    static getAllDownwards(piece: PieceModel){
        var board: BoardModel = piece.getBoardModel();
        var result: Move[] = new Array();

        var x = piece.getPos().getX();
        var y = piece.getPos().getY() + 1;

        while(piece.getBoardModel().isValidPosition(new Pos(x, y))){
            if(!piece.getBoardModel().isFree(new Pos(x, y))){
                if(piece.getBoardModel().getPieceFromPosition(new Pos(x, y)).getColor() != piece.getColor()){
                    result.push(new Move(piece.getPos(), new Pos(x, y)));
                    break;
                }
                else{
                    break;
                }
            }
            result.push(new Move(piece.getPos(), new Pos(x, y)));
            y += 1;
        }

        return new MoveCollection(result);
    }

    static getAllLeft(piece: PieceModel){
        var board: BoardModel = piece.getBoardModel();
        var result: Move[] = new Array();

        var x = piece.getPos().getX() - 1;
        var y = piece.getPos().getY();

        while(piece.getBoardModel().isValidPosition(new Pos(x, y))){
            if(!piece.getBoardModel().isFree(new Pos(x, y))){
                if(piece.getBoardModel().getPieceFromPosition(new Pos(x, y)).getColor() != piece.getColor()){
                    result.push(new Move(piece.getPos(), new Pos(x, y)));
                    break;
                }
                else{
                    break;
                }
            }
            result.push(new Move(piece.getPos(), new Pos(x, y)));
            x -= 1;
        }

        return new MoveCollection(result);
    }

    static getAllRight(piece: PieceModel): MoveCollection{
        var board: BoardModel = piece.getBoardModel();
        var result: Move[] = new Array();

        var x = piece.getPos().getX() + 1;
        var y = piece.getPos().getY();

        while(piece.getBoardModel().isValidPosition(new Pos(x, y))){
            if(piece.getBoardModel().isFree(new Pos(x, y)) == false){
                if(piece.getBoardModel().getPieceFromPosition(new Pos(x, y)).getColor() != piece.getColor()){
                    result.push(new Move(piece.getPos(), new Pos(x, y)));
                    break;
                }
                else{
                    break;
                }
            }
            result.push(new Move(piece.getPos(), new Pos(x, y)));
            x += 1;
        }

        return new MoveCollection(result);
    }

    static getAllCardinal(piece: PieceModel){
        var result: MoveCollection = new MoveCollection();

        result.addAll(MoveFactory.getAllRight(piece));
        result.addAll(MoveFactory.getAllLeft(piece));
        result.addAll(MoveFactory.getAllUpwards(piece));
        result.addAll(MoveFactory.getAllDownwards(piece));

        return result;
    }

    static getAllLeftUpDiagonal(piece: PieceModel){
        var board: BoardModel = piece.getBoardModel();
        var result: MoveCollection = new MoveCollection();

        var x = piece.getPos().getX() - 1;
        var y = piece.getPos().getY() - 1;

        while(piece.getBoardModel().isValidPosition(new Pos(x, y))) {
            if (!piece.getBoardModel().isFree(new Pos(x, y))) {
                if (piece.getBoardModel().getPieceFromPosition(new Pos(x, y)).getColor() != piece.getColor()) {
                    result.add(new Move(piece.getPos(), new Pos(x, y)));
                    break;
                }
                else {
                    break;
                }
            }
            result.add(new Move(piece.getPos(), new Pos(x, y)));
            x -= 1;
            y -= 1;
        }


        return result;
    }

    static getAllRightUpDiagonal(piece: PieceModel){
        var board: BoardModel = piece.getBoardModel();
        var result: MoveCollection = new MoveCollection();

        var x = piece.getPos().getX() + 1;
        var y = piece.getPos().getY() - 1;

    while(piece.getBoardModel().isValidPosition(new Pos(x, y))){
        if(!piece.getBoardModel().isFree(new Pos(x, y))){
            if(piece.getBoardModel().getPieceFromPosition(new Pos(x, y)).getColor() != piece.getColor()){
                result.add(new Move(piece.getPos(), new Pos(x, y)));
                break;
            }
            else{
                break;
            }
            }
            result.add(new Move(piece.getPos(), new Pos(x, y)));
            x += 1;
            y -= 1;
        }

        return result;
    }

    static getAllRightDownDiagonal(piece: PieceModel){
        var board: BoardModel = piece.getBoardModel();
        var result: MoveCollection = new MoveCollection();

        var x = piece.getPos().getX() + 1;
        var y = piece.getPos().getY() + 1;


        while(piece.getBoardModel().isValidPosition(new Pos(x, y))){
            if(!piece.getBoardModel().isFree(new Pos(x, y))){
                if(piece.getBoardModel().getPieceFromPosition(new Pos(x, y)).getColor() != piece.getColor()){
                    result.add(new Move(piece.getPos(), new Pos(x, y)));
                    break;
                }
                else{
                    break;
                }
            }
            result.add(new Move(piece.getPos(), new Pos(x, y)));
            x += 1;
            y += 1;
        }

        return result;
    }

    static getAllLeftDownDiagonal(piece: PieceModel){
        var board: BoardModel = piece.getBoardModel();
        var result: MoveCollection = new MoveCollection();

        var x = piece.getPos().getX() - 1;
        var y = piece.getPos().getY() + 1;

            while (piece.getBoardModel().isValidPosition(new Pos(x, y))) {
                if (!piece.getBoardModel().isFree(new Pos(x, y))) {
                    if (piece.getBoardModel().getPieceFromPosition(new Pos(x, y)).getColor() != piece.getColor()) {
                        result.add(new Move(piece.getPos(), new Pos(x, y)));
                        break;
                    }
                    else {
                        break;
                    }
                }
                result.add(new Move(piece.getPos(), new Pos(x, y)));
                x -= 1;
                y += 1;
            }


        return result;
    }

    static getAllDiagonal(piece: PieceModel){
        var result: MoveCollection = new MoveCollection();

        result.addAll(MoveFactory.getAllLeftDownDiagonal(piece));
        result.addAll(MoveFactory.getAllRightDownDiagonal(piece));
        result.addAll(MoveFactory.getAllRightUpDiagonal(piece));
        result.addAll(MoveFactory.getAllLeftUpDiagonal(piece));

        return result;
    }

    static getRelativeToPiece(piece: PieceModel, x: number, y: number){
        var result: MoveCollection = new MoveCollection();

        var newX: number = piece.getPos().getX() + x;
        var newY: number = piece.getPos().getY() + y;

        if(piece.getBoardModel().isValidPosition(new Pos(newX, newY))){
            if (!piece.getBoardModel().isFree(new Pos(newX, newY))) {
                if (piece.getBoardModel().getPieceFromPosition(new Pos(newX, newY)).getColor() != piece.getColor()) {
                    result.add(new Move(piece.getPos(), new Pos(newX, newY)));
                }
            }
            else{
                result.add(new Move(piece.getPos(), new Pos(newX, newY)));
            }
        }

        return result;
    }

    static getRelativeToPieceNonCapturing(piece: PieceModel, x: number, y: number){
        var result: MoveCollection = new MoveCollection();
        var newX: number = piece.getPos().getX() + x;
        var newY: number = piece.getPos().getY() + y;

        if(piece.getBoardModel().isValidPosition(new Pos(newX, newY))){
            if (!piece.getBoardModel().isFree(new Pos(newX, newY))) {
            }
            else{
                result.add(new Move(piece.getPos(), new Pos(newX, newY)));
            }
        }

        return result;
    }

    static getRelativeToPieceOnlyIfCapturable(piece: PieceModel, x: number, y: number){
        var result: MoveCollection = new MoveCollection();

        var newX: number = piece.getPos().getX() + x;
        var newY: number = piece.getPos().getY() + y;

        if(piece.getBoardModel().isValidPosition(new Pos(newX, newY))){
            if (!piece.getBoardModel().isFree(new Pos(newX, newY))) {
                if (piece.getBoardModel().getPieceFromPosition(new Pos(newX, newY)).getColor() != piece.getColor()) {
                    result.add(new Move(piece.getPos(), new Pos(newX, newY)));
                }
            }
        }

        return result;
    }

    static getLineForward(piece: PieceModel, length: number, direction: number){
        var result: MoveCollection = new MoveCollection();

        if(direction > 0){
            var count = length;
            var newX: number = piece.getPos().getX();
            var newY: number = piece.getPos().getY() - 1;

            while(count > 0){
                if(piece.getBoardModel().isValidPosition(new Pos(newX, newY))){
                    if (!piece.getBoardModel().isFree(new Pos(newX, newY))) {
                        if (piece.getBoardModel().getPieceFromPosition(new Pos(newX, newY)).getColor() != piece.getColor()) {
                            result.add(new Move(piece.getPos(), new Pos(newX, newY)));
                            count--;
                            newY--;
                        }
                    }
                    else{
                        result.add(new Move(piece.getPos(), new Pos(newX, newY)));
                        count--;
                        newY--;
                    }
                }
            }
        }
        if(direction < 0){
            var count = length;
            var newX: number = piece.getPos().getX();
            var newY: number = piece.getPos().getY() + 1;

            while(count > 0){
                if(piece.getBoardModel().isValidPosition(new Pos(newX, newY))){
                    if (!piece.getBoardModel().isFree(new Pos(newX, newY))) {
                        if (piece.getBoardModel().getPieceFromPosition(new Pos(newX, newY)).getColor() != piece.getColor()) {
                            result.add(new Move(piece.getPos(), new Pos(newX, newY)));
                            count--;
                            newY++;
                        }
                    }
                    else{
                        result.add(new Move(piece.getPos(), new Pos(newX, newY)));
                        count--;
                        newY++;
                    }
                }
            }
        }

        return result;
    }

    static getLineForwardNoncapturing(piece: PieceModel, length: number, direction: number){
        var result: MoveCollection = new MoveCollection();

        if(direction > 0){
            var count = length;
            var newX: number = piece.getPos().getX();
            var newY: number = piece.getPos().getY() - 1;

            while(count > 0){
                if(piece.getBoardModel().isValidPosition(new Pos(newX, newY))){
                    if (!piece.getBoardModel().isFree(new Pos(newX, newY))) {
                        break;
                    }
                    else{
                        result.add(new Move(piece.getPos(), new Pos(newX, newY)));
                        count--;
                        newY--;
                    }
                }
            }
        }
        if(direction < 0){
            var count = length;
            var newX: number = piece.getPos().getX();
            var newY: number = piece.getPos().getY() + 1;

            while(count > 0){
                if(piece.getBoardModel().isValidPosition(new Pos(newX, newY))){
                    if (!piece.getBoardModel().isFree(new Pos(newX, newY))) {
                        break;
                    }
                    else{
                        result.add(new Move(piece.getPos(), new Pos(newX, newY)));
                        count--;
                        newY++;
                }
                }
            }
        }

        return result;
    }


}abstract class PieceModel{
    private pos: Pos;
    private color: Color;
    private boardModel: BoardModel;
    private type: PieceType;

    constructor(board: BoardModel, pos: Pos, color: Color, type: PieceType){
        this.pos = pos;
        this.color = color;
        this.boardModel = board;
        this.type = type;
    }

    getPos(): Pos{
        return this.pos;
    }

    getColor(): Color{
        return this.color;
    }

    getBoardModel(): BoardModel{
        return this.boardModel;
    }

    getType(): PieceType{
        return this.type;
    }

    getPossibleMoves(): MoveCollection{
        return MoveFactory.getAllUpwards(this);
    }

    abstract onMove();
    abstract giveInternalAttributes(piece: PieceModel);
}class RookModel extends PieceModel{

    constructor(board: BoardModel, pos: Pos, color: Color){
        super(board, pos, color, PieceType.ROOK);
    }

    onMove(){}
    giveInternalAttributes(piece: PieceModel){}

    getPossibleMoves(): MoveCollection{
        return MoveFactory.getAllCardinal(this);
    }
}class PawnModel extends PieceModel{
    hasMoved: boolean;

    constructor(board: BoardModel, pos: Pos, color: Color){
        super(board, pos, color, PieceType.PAWN);
    }

    onMove(){
       this.hasMoved = true;
    }

    giveInternalAttributes(piece: PieceModel) {
        var currPiece = piece as PawnModel;
        currPiece.hasMoved = this.hasMoved;

    }

    getDirection(): number{
        return this.getBoardModel().getDirection(this.getColor());
    }

    getPossibleMoves(): MoveCollection{

        if(this.hasMoved){
            return MoveFactory.getRelativeToPieceNonCapturing(this, 0, -1 * this.getDirection())
                    .addAll(MoveFactory.getRelativeToPieceOnlyIfCapturable(this, -1, -1 * this.getDirection()))
                .addAll(MoveFactory.getRelativeToPieceOnlyIfCapturable(this, 1, -1 * this.getDirection()));
        }
        else{
            //alert(MoveFactory.getLineForward(this, 2, this.getDirection()).getMoves.length);
            return MoveFactory.getRelativeToPieceNonCapturing(this, 0, -1 * this.getDirection())
                .addAll(MoveFactory.getLineForwardNoncapturing(this, 2, this.getDirection())
                .addAll(MoveFactory.getRelativeToPieceOnlyIfCapturable(this, -1, -1 * this.getDirection()))
                .addAll(MoveFactory.getRelativeToPieceOnlyIfCapturable(this, 1, -1 * this.getDirection())));
        }

    }
}class KnightModel extends PieceModel{

    constructor(board: BoardModel, pos: Pos, color: Color){
        super(board, pos, color, PieceType.KNIGHT);
    }

    onMove(){}
    giveInternalAttributes(piece: PieceModel){}

    getPossibleMoves(): MoveCollection{
        return MoveFactory.getRelativeToPiece(this, -2, -1)
        .addAll(MoveFactory.getRelativeToPiece(this, 2, -1))
        .addAll(MoveFactory.getRelativeToPiece(this, -2, 1))
        .addAll(MoveFactory.getRelativeToPiece(this, 2, 1))
        .addAll(MoveFactory.getRelativeToPiece(this, 1, -2))
        .addAll(MoveFactory.getRelativeToPiece(this, -1, 2))
        .addAll(MoveFactory.getRelativeToPiece(this, 1, 2))
        .addAll(MoveFactory.getRelativeToPiece(this, -1, -2));
    }
}class BishopModel extends PieceModel{

    constructor(board: BoardModel, pos: Pos, color: Color){
        super(board, pos, color, PieceType.BISHOP);
    }

    onMove(){}
    giveInternalAttributes(piece: PieceModel){}

    getPossibleMoves(): MoveCollection{
        return MoveFactory.getAllDiagonal(this);
    }
}class KingModel extends PieceModel{

    constructor(board: BoardModel, pos: Pos, color: Color){
        super(board, pos, color, PieceType.KING);
    }

    onMove(){}
    giveInternalAttributes(piece: PieceModel){}

    getPossibleMoves(): MoveCollection{
        return MoveFactory.getRelativeToPiece(this, 1, 1)
        .addAll(MoveFactory.getRelativeToPiece(this, 1, -1))
        .addAll(MoveFactory.getRelativeToPiece(this, -1, 1))
        .addAll(MoveFactory.getRelativeToPiece(this, -1, -1))
        .addAll(MoveFactory.getRelativeToPiece(this, 0, -1))
        .addAll(MoveFactory.getRelativeToPiece(this, 0, 1))
        .addAll(MoveFactory.getRelativeToPiece(this, -1, 0))
        .addAll(MoveFactory.getRelativeToPiece(this, 1, 0));
    }
}class QueenModel extends PieceModel{

    constructor(board: BoardModel, pos: Pos, color: Color){
        super(board, pos, color, PieceType.QUEEN);
    }

    onMove(){}
    giveInternalAttributes(piece: PieceModel){}

    getPossibleMoves(): MoveCollection{
        return MoveFactory.getAllCardinal(this)
            .addAll(MoveFactory.getAllDiagonal(this));
    }
}class PieceFactory{

    static createPiece(board: BoardModel, pos: Pos, color: Color, type: PieceType): PieceModel{
        var newPiece: PieceModel;
        switch(type){
            case PieceType.ROOK: newPiece = new RookModel(board, pos, color); break;
            case PieceType.BISHOP: newPiece = new BishopModel(board, pos, color); break;
            case PieceType.PAWN: newPiece = new PawnModel(board, pos, color); break;
            case PieceType.KING: newPiece = new KingModel(board, pos, color); break;
            case PieceType.KNIGHT: newPiece = new KnightModel(board, pos, color); break;
            case PieceType.QUEEN: newPiece = new QueenModel(board, pos, color); break;
        }
        return newPiece;
    }

    static createPieceByTransposition(pos: Pos, piece: PieceModel): PieceModel{
        var newPiece: PieceModel = PieceFactory.createPiece(piece.getBoardModel(), pos, piece.getColor(), piece.getType());
        piece.giveInternalAttributes(newPiece);
        return newPiece;
    }
}class BoardModel{
    HEIGHT: number;
    WIDTH: number;

    pos2PieceMap: Map<Pos, PieceModel> = new Map();

    constructor(argWidth:number, argHeight:number){
        this.HEIGHT = argHeight;
        this.WIDTH = argWidth;

        for(var y:number = 0; y < argHeight; y++){
            for(var x:number = 0; x < argWidth; x++){
                this.pos2PieceMap.set(new Pos(x, y), null);
            }
        }
    }

    addPiece(type: PieceType, x: number, y: number, color: Color){
        this.placePiece(PieceFactory.createPiece(this, new Pos(x, y), color, type));
    }

    placePiece(piece: PieceModel){
        this.pos2PieceMap.set(piece.getPos(), piece);
    }

    getDirection(color: Color): number{
        if(Color.WHITE == color){
            return 1;
        }
        else if(Color.BLACK == color){
            return -1;
        }
    }

    isFree(pos: Pos): boolean{
        var result: boolean;
        this.pos2PieceMap.forEach((value, key, map) => {
            if (pos.equals(key)) {
                result = (value == null || value == undefined);
            }
        });

        return result;
    }

    isCapturable(pos: Pos, color: Color): boolean{
        return this.isFree(pos)
    }

    getHeight(): number{
        return this.HEIGHT;
    }

    getWidth(): number{
        return this.WIDTH;
    }

    getAllPieces(): PieceModel[]{
        var result: PieceModel[] = new Array();
        this.pos2PieceMap.forEach((value, key, map) => {
            if(value != null){
                result.push(value);
            }
        });
        return result;
    }

    getAllPiecesOfColor(color: Color): PieceModel[]{
        var result: PieceModel[] = new Array();
        this.pos2PieceMap.forEach((value, key, map) => {
            if(value != null && value != undefined ){
                if(value.getColor() == color){
                    result.push(value);
                }
            }
        });
        return result;
    }

    removePiece(pos: Pos){
        this.pos2PieceMap.forEach((value, key, map) => {
            if(key.equals(pos)){
                this.pos2PieceMap.delete(key);
            }
        });
        this.pos2PieceMap.set(pos, null);
    }

    executeMove(move: Move){
        var originalPiece: PieceModel = this.getPieceFromPosition(move.getOrigin());
        originalPiece.onMove();
        this.movePiece(originalPiece, move.getDest());
    }

    movePiece(piece: PieceModel, dest: Pos){
        this.removePiece(piece.getPos());
        this.removePiece(dest);
        var transposedPiece = PieceFactory.createPieceByTransposition(dest, piece);
        this.placePiece(transposedPiece);
    }

    isValidPosition(pos: Pos): boolean{
        var result = false;
        this.pos2PieceMap.forEach((value, key, map) => {
            if (pos.equals(key)) {
                result = true;
            }
        });

        return result;
    }

    serialize(): string{
        var result = "";
        for(var y: number = 0; y < this.getHeight(); y++){
            for (var x: number = 0; x < this.getWidth(); x++){
                var thisPiece = this.getPieceFromPosition(new Pos(x, y));

                result += "[";
                if(thisPiece != null){
                    result += thisPiece.getType() + "_";

                    if(thisPiece.getColor() == Color.BLACK){
                        result += "B";
                    }
                    else{
                        result += "W";
                    }
                }
                result += "],";
            }
            result = result.substring(0, result.length - 1);
            result += "/";
        }
        result = result.substring(0, result.length - 1);
        return result;
    }

    reset(){
        this.pos2PieceMap.clear();
        for(var y:number = 0; y < this.getHeight(); y++){
            for(var x:number = 0; x < this.getWidth(); x++){
                this.pos2PieceMap.set(new Pos(x, y), null);
            }
        }
    }

    getAllMovesForColor(color: Color): MoveCollection{
        var pieces: PieceModel[] = this.getAllPiecesOfColor(color);
        var resultArr: MoveCollection = new MoveCollection();
        for(var pieceIdx in pieces){
            var eachPiece: PieceModel = pieces[pieceIdx];
            resultArr.addAll(eachPiece.getPossibleMoves());
        }
        return resultArr;
    }

    populateFromSerial(serial: string) {
        this.reset();
        var rows:string[] = serial.split("/");
        for (var y = 0; y < rows.length; y++) {
            var row = rows[y];
            var squares:string[] = row.split(",");
            var length = squares.length;
            for (var x = 0; x < squares.length; x++) {
                var sqrData:string = squares[x].substring(1, squares[x].length - 1);

                if (sqrData.length != 0) {
                    var sqrDataSplit = sqrData.split("_");
                    var thisColor:Color;

                    if (sqrDataSplit[1] == "W") {
                        thisColor = Color.WHITE;
                    }
                    else {
                        thisColor = Color.BLACK;
                    }
                    this.addPiece(+sqrDataSplit[0], x, y, thisColor);
                }
            }
        }
    }

    getPieceFromPosition(pos: Pos): any{
        var result;
        this.pos2PieceMap.forEach((value, key, map) => {
            if (pos.equals(key)) {
                result = this.pos2PieceMap.get(key);
            }
        });

        return result;
    }
}abstract class Player{

	abstract getNextMove(board): Move;

}class MiniMaxPlayer extends Player{
	myColor: Color;

	constructor(color: Color){
		super();
		this.myColor = color;
	}

	getNextMove(board: BoardModel):Move{
		var moves: MoveCollection = board.getAllMovesForColor(this.myColor);
		moves.shuffle();
		var bestValuation: number = Number.MAX_SAFE_INTEGER * -1;
		var bestMove: Move = this.rootMiniMax(board, 2, this.myColor);
		return bestMove;
	}
	
	rootMiniMax(board: BoardModel, depth: number, color: Color): Move{
		var bestMove: Move;
		var bestValuation: number = Number.MAX_SAFE_INTEGER * -1;
		var alpha = Number.MAX_SAFE_INTEGER * -1;
		var beta = Number.MAX_SAFE_INTEGER;
			var maxMoves: MoveCollection = board.getAllMovesForColor(color);
			maxMoves.shuffle();
			for(var maxMoveIdx in maxMoves.getMoves()) {
				var eachMaxMove:Move = maxMoves.getMoves()[maxMoveIdx];
				var currentValuation = this.minimax(eachMaxMove, board, depth - 1, this.swapColor(color), alpha, beta, false);
				if(currentValuation >= bestValuation){
					bestValuation = currentValuation;
					bestMove = eachMaxMove;
				}
			}

		return bestMove;
	}
	
	minimax(move: Move, board: BoardModel, depth: number, color: Color, alpha: number, beta: number, maximize: boolean): number{
		var newBoard: BoardModel = this.applyMove(move, board);
		if(depth == 0){
			return this.evaluate(newBoard, color);
		}
		var bestValuation: number;
		if(maximize){
			bestValuation = Number.MAX_SAFE_INTEGER * -1;
			var maxMoves: MoveCollection = newBoard.getAllMovesForColor(color);
			maxMoves.shuffle();
			for(var maxMoveIdx in maxMoves.getMoves()) {
				var eachMaxMove:Move = maxMoves.getMoves()[maxMoveIdx];
				bestValuation = Math.max(bestValuation, this.minimax(eachMaxMove, newBoard, depth - 1, this.swapColor(color), alpha, beta, false));
				alpha = Math.max(alpha, bestValuation);
				if(beta <= alpha){
					break;
				}
			}
		}
		else if(!maximize){
			bestValuation = Number.MAX_SAFE_INTEGER;
			var minMoves: MoveCollection = newBoard.getAllMovesForColor(color);
			minMoves.shuffle();
			for(var minMoveIdx in minMoves.getMoves()) {
				var eachMinMove:Move = minMoves.getMoves()[minMoveIdx];
				bestValuation = Math.min(bestValuation, this.minimax(eachMinMove, newBoard, depth - 1, this.swapColor(color), alpha, beta, true));
				beta = Math.min(beta, bestValuation);
				if(beta <= alpha){
					break;
				}
			}
		}
		return bestValuation;
	}

	swapColor(color: Color): Color{
		if(color == Color.BLACK){
			return Color.WHITE;
		}
		else{
			return Color.BLACK;
		}
	}

	applyMove(move: Move, board: BoardModel): BoardModel{
		var newBoard = new BoardModel(board.getHeight(), board.getWidth());
		newBoard.populateFromSerial(board.serialize());
		newBoard.executeMove(move);
		return newBoard;
	}


	evaluate(board: BoardModel, color: Color): number{
		var result = 0;
		/*result += board.getAllPiecesOfColor(color).length;
		result -= board.getAllPiecesOfColor(this.swapColor(color)).length;*/
		result += this.getMaterial(board, color);
		result += (this.getMobility(board, color) * 0.01);
		return result;
	}

	getMaterial(board: BoardModel, color: Color){
		var pieces = board.getAllPieces();
		var value = 0;
		for(var pieceIdx in pieces){
			var eachPiece =  pieces[pieceIdx];
			var thisValue = 0;
			switch(eachPiece.getType()){
				case PieceType.ROOK: thisValue += 5; break;
				case PieceType.PAWN: thisValue += 1; break;
				case PieceType.QUEEN: thisValue += 9; break;
				case PieceType.KNIGHT: thisValue += 3; break;
				case PieceType.BISHOP: thisValue += 3; break;
				case PieceType.KING: thisValue += 1000; break;
			}
			if(eachPiece.getColor() == color){
				value += thisValue;
			}
			else{
				value -= thisValue;
			}
		}
		return value;
	}

	getMobility(board: BoardModel, color: Color){
		var myMoves = board.getAllMovesForColor(color);
		var oppMoves = board.getAllMovesForColor(this.swapColor(color));
		return myMoves.getMoves().length - oppMoves.getMoves().length;
	}
}class ConsoleEntry extends HTMLObject{
    text: string;

    constructor(left: number, top: number, width: number, height: number, text: string){
        super();
        this.setTopPos(top);
        this.setLeftPos(left);
        this.setWidth(width);
        this.setHeight(height);
        this.setText(text);
    }

    setText(text: string){
        this.text = text;
    }

    getText(): string{
        return this.text;
    }

    toHTML(): string{
        var innerDiv: string = "{msg}";
        var builder = new HTMLBuilder();
        builder.newDiv()
            .addStyle("position", "absolute")
            .addStyle("left", this.getLeftPos() + "")
            .addStyle("top", this.getTopPos() + "")
            .addStyle("width", this.getWidth() + "px")
            .addStyle("height", this.getHeight() + "px")
            .addStyle("border", "1px solid black");

        builder.addInnerDiv(innerDiv.replace("{msg}", this.getText()));

        return builder.toString();
    }
}class MyConsole extends HTMLObject{
    lines: ConsoleEntry[] = new Array();
    entryHeight: number = 20;
    consoleWidth: number = 500;
    consoleHeight: number = 100;

    constructor(leftPos: number, upPos: number){
        super();
        this.setHeight(this.consoleHeight);
        this.setWidth(this.consoleWidth);
        this.setLeftPos(leftPos);
        this.setTopPos(upPos);
        this.setId("my-console");
    }

    addEntry(text: string){
        var newEntry: ConsoleEntry = new ConsoleEntry(0, (this.entryHeight * (this.lines.length)) - 1, this.getWidth() - 20, this.entryHeight, text);
        this.lines.push(newEntry);
    }

    toHTML(): string{
        var text: string = "";

        for(var lineIdx in this.lines){
            text += this.lines[lineIdx].toHTML();
        }

        var builder = new HTMLBuilder();
        builder.newDiv()
            .addStyle("overflow-y", "scroll")
            .addStyle("position", "absolute")
            .addStyle("border", "1px solid black")
            .addStyle("left", this.getLeftPos() + "")
            .addStyle("top", this.getTopPos() + "")
            .addStyle("width", this.getWidth() + "px")
            .addStyle("height", this.getHeight() + "px")
            .setId(this.getId());

        builder.addInnerDiv(text);
        return builder.toString();
    }
}class ConsoleController{
    static console: MyConsole = new MyConsole(100, 600);
    static run(){
        ConsoleController.update();
        window.onkeyup = function(e) {
            var key = e.keyCode ? e.keyCode : e.which;
            if (key == 13) {
                ConsoleController.log("New Entry");
            }

        }
    }
    static log(txt: string){
        ConsoleController.console.addEntry(txt);
        ConsoleController.update();
    }
    static update(){
        document.body.innerHTML += ConsoleController.console.toHTML();
        var element = document.getElementById("my-console");
        element.scrollTop = element.scrollHeight - element.clientHeight;
    }
}
class GlobalController{
	static state: State;
	static changeStateCallbacks: Map<State, CallbackPool> = new Map<State, CallbackPool>();
	static boardView: Board;
	static boardModel: BoardModel;

	static SELECTION_TOGGLE: boolean = false;
	static SELECTED_PIECE: PieceModel = null;
	static SELECTED_OPP_PIECE: PieceModel = null;
	static WHITE_CLICK_ON: boolean = true;

	static STANDARD_BOARD: string = "[4_B],[2_B],[3_B],[5_B],[6_B],[3_B],[2_B],[4_B]/[1_B],[1_B],[1_B],[1_B],[1_B],[1_B],[1_B],[1_B]/[],[],[],[],[],[],[],[]/[],[],[],[],[],[],[],[]/[],[],[],[],[],[],[],[]/[],[],[],[],[],[],[],[]/[1_W],[1_W],[1_W],[1_W],[1_W],[1_W],[1_W],[1_W]/[4_W],[2_W],[3_W],[5_W],[6_W],[3_W],[2_W],[4_W]";

	static opponent: MiniMaxPlayer = new MiniMaxPlayer(Color.BLACK);

	static start(){
	    GlobalController.boardView = new Board(8, 8);
		GlobalController.boardModel = new BoardModel(8,8);
		GlobalController.setStandard();
		GlobalController.initializeStateCallbacks();
		ConsoleController.run();
	}

	static initializeStateCallbacks(){
		GlobalController.addStateChangeCallback(State.WHITES_TURN,
			() => {
				if(GlobalController.hasLost(Color.WHITE)){
					ConsoleController.log("White has lost.");
					GlobalController.update();
				}
				else{
					if(GlobalController.isInCheck(Color.WHITE)){
						ConsoleController.log("White is in check");
					}
					GlobalController.WHITE_CLICK_ON = true;
					GlobalController.update();
				}
			});
		GlobalController.addStateChangeCallback(State.BLACKS_TURN,
			() => {
				if(GlobalController.hasLost(Color.BLACK)){
					ConsoleController.log("Black has lost.");
					GlobalController.update();
				}
                else {
					if(GlobalController.isInCheck(Color.BLACK)){
						ConsoleController.log("Black is in check");
					}
					GlobalController.WHITE_CLICK_ON = false;
					GlobalController.syncToBoard();
					GlobalController.update();
					//GlobalController.makeRandomMoveForBlack();
                    setTimeout(() => {
                        GlobalController.makeMoveForBlack();
                        GlobalController.syncToBoard();
					    GlobalController.changeState(State.WHITES_TURN);
                    }, 10);
				}
			});
		GlobalController.addStateChangeCallback(State.FINISH,
			() => {
				//print result
			});
	}

	static setStandard(){
		GlobalController.boardModel.populateFromSerial(GlobalController.STANDARD_BOARD);
		GlobalController.syncToBoard();
		GlobalController.update();
	}

	static syncToBoard() {
		GlobalController.boardView = Board.fromSerial(GlobalController.boardModel.serialize());
	}

    static update() {
        document.body.innerHTML = GlobalController.boardView.toHTML();
        ConsoleController.update();
        if (GlobalController.WHITE_CLICK_ON) {
            GlobalController.setWhiteClickListeners();
        }
    }

	static hasLost(color: Color): boolean{
		var pieces: PieceModel[] = GlobalController.boardModel.getAllPiecesOfColor(color);
		for(var pieceIdx in pieces){
			var eachPiece = pieces[pieceIdx];
			if(eachPiece.getType() == PieceType.KING){
				return false;
			}
		}
		return true;
	}

	static isInCheck(color: Color): boolean{
		var pieces: PieceModel[] = GlobalController.boardModel.getAllPiecesOfColor(color);
		for(var pieceIdx in pieces){
			var eachPiece = pieces[pieceIdx];
			if(eachPiece.getType() == PieceType.KING){
				if(GlobalController.boardModel.getAllMovesForColor(GlobalController.swapColor(color)).containsDestination(eachPiece.getPos())){
					return true;
				}
			}
		}
		return false;
	}

	static setWhiteClickListeners(){
		var pieces: Piece[] = GlobalController.boardView.getPieces();
		var squares: Square[] = GlobalController.boardView.getSquares();
		for (var piece in pieces) {
			var each = pieces[piece];
            if (each.getColor() == Color.WHITE) {
                var coSqr: Square = GlobalController.boardView.getSquareAtPos(each.getX(), each.getY());
				document.getElementById(coSqr.getId() + "").setAttribute("onclick", "whiteClickListener(\""+ + each.getId() + "\")");
			}
			else{
				var coSqr: Square = GlobalController.boardView.getSquareAtPos(each.getX(), each.getY());
				document.getElementById(coSqr.getId() + "").setAttribute("onclick", "blackClickListener(\""+ + each.getId() + "\")");
			}
		}
		for (var square in squares) {
			var eachSqr:Square = squares[square];
            if (document.getElementById(eachSqr.getId() + "").onclick == null || document.getElementById(eachSqr.getId() + "").onclick == undefined) {
                document.getElementById(eachSqr.getId() + "").setAttribute("onclick", "squareClickListener(\"" + eachSqr.getId() + "\")");   
            }
		}
	}

	static changeState(newState: State){
		this.state = newState;
		GlobalController.fireCallbacksForState(this.state);
	}

	static swapColor(color: Color): Color{
		if(color == Color.BLACK){
			return Color.WHITE;
		}
		else{
			return Color.BLACK;
		}
	}

	static makeRandomMoveForBlack(){
		var allBlkMoves: MoveCollection = GlobalController.boardModel.getAllMovesForColor(Color.BLACK);
		allBlkMoves.shuffle();
		var randomMove = allBlkMoves.getMoves()[0];
		//ConsoleController.log(randomMove.getOrigin().toString() + " to " + randomMove.getDest().toString());
		GlobalController.boardModel.executeMove(randomMove);
	}

	static makeMoveForBlack(){
		var nextMove = GlobalController.opponent.getNextMove(GlobalController.boardModel);
		GlobalController.boardModel.executeMove(nextMove);
	}

	static addStateChangeCallback(newState: State, callback: {(): void;}){
		var callbacks = GlobalController.changeStateCallbacks.get(newState);
		if(callbacks == null || callbacks == undefined){
			var newCallbackPool = new CallbackPool(callback);
			GlobalController.changeStateCallbacks.set(newState, newCallbackPool);
		}
		else{
			callbacks.addCallback(callback);
		}
	}
	
	static fireCallbacksForState(state: State){
		var callbacks = GlobalController.changeStateCallbacks.get(state);
		if(callbacks != null && callbacks != undefined){
			callbacks.fire();
		}
	}
}

var whiteClickListener = (id: string) => {
	var changeFlag = false;
	var meView = GlobalController.boardView.getPieceById(id);
	var meModel: PieceModel = GlobalController.boardModel.getPieceFromPosition(new Pos(meView.getX(), meView.getY()));
	var meSqr = GlobalController.boardView.getSquareAtPos(meView.getX(), meView.getY());
	if(!GlobalController.SELECTION_TOGGLE){
		GlobalController.SELECTED_PIECE = meModel;
		GlobalController.SELECTION_TOGGLE = true;
		meSqr.setHexColor(StaticColors.SQUARE_SELECTION_BLUE);
		var moves: MoveCollection = meModel.getPossibleMoves();
		for(var eachMoveIdx in moves.getMoves()){
			var eachMove: Move = moves.getMoves()[eachMoveIdx];
			var possibleSqr: Square = GlobalController.boardView.getSquareAtPos(eachMove.getDest().getX(), eachMove.getDest().getY());
			possibleSqr.setHexColor(StaticColors.SQUARE_SELECTION_BLUE);
		}
		GlobalController.SELECTED_PIECE = meModel;
	}
	else if (GlobalController.SELECTION_TOGGLE) {
		var move: Move = new Move(GlobalController.SELECTED_PIECE.getPos(), new Pos(meView.getX(), meView.getY()));
		if(GlobalController.SELECTED_PIECE.getPossibleMoves().contains(move)){
			GlobalController.boardModel.executeMove(move);
			changeFlag = true;
			GlobalController.syncToBoard();
			GlobalController.SELECTION_TOGGLE = false;
			GlobalController.SELECTED_PIECE= null;
			GlobalController.boardView.unselectAllSquares();
		}
		else if(GlobalController.SELECTED_PIECE.getPos().equals(meModel.getPos())){
			GlobalController.boardView = Board.fromSerial(GlobalController.boardModel.serialize());
			GlobalController.SELECTION_TOGGLE = false;
			GlobalController.SELECTED_PIECE= null;
			GlobalController.boardView.unselectAllSquares();
		}
	}
	if(changeFlag){
		GlobalController.update();
		GlobalController.changeState(State.BLACKS_TURN);
	}
	else{
		GlobalController.update();
	}
}

var squareClickListener = (id: string) => {
	var changeFlag = false;
	var meView: Square = GlobalController.boardView.getSquareById(id);
	if (GlobalController.SELECTION_TOGGLE) {
		var move: Move = new Move(GlobalController.SELECTED_PIECE.getPos(), new Pos(meView.getX(), meView.getY()));
		if(GlobalController.SELECTED_PIECE.getPossibleMoves().contains(move)){
			GlobalController.boardModel.executeMove(move);
			changeFlag = true;
			GlobalController.syncToBoard();
			GlobalController.SELECTION_TOGGLE= false;
			GlobalController.SELECTED_PIECE= null;
			GlobalController.boardView.unselectAllSquares();
		}
	}
	if(changeFlag){
		GlobalController.update();
		GlobalController.changeState(State.BLACKS_TURN);
	}
	else{
		GlobalController.update();
	}
}

var blackClickListener = (id: string) => {
	var changeFlag = false;
	var meView = GlobalController.boardView.getPieceById(id);
	var meModel: PieceModel = GlobalController.boardModel.getPieceFromPosition(new Pos(meView.getX(), meView.getY()));
	var meSqr = GlobalController.boardView.getSquareAtPos(meView.getX(), meView.getY());
	if (GlobalController.SELECTION_TOGGLE && GlobalController.SELECTED_PIECE != null) {
		var move: Move = new Move(GlobalController.SELECTED_PIECE.getPos(), new Pos(meView.getX(), meView.getY()));
		if(GlobalController.SELECTED_PIECE.getPossibleMoves().contains(move)){
			GlobalController.boardModel.executeMove(move);
			changeFlag = true;
			GlobalController.syncToBoard();
			GlobalController.SELECTION_TOGGLE= false;
			GlobalController.SELECTED_PIECE= null;
			GlobalController.boardView.unselectAllSquares();
		}
	}
	else{
		if (GlobalController.SELECTION_TOGGLE && GlobalController.SELECTED_PIECE == null) {
			if(GlobalController.SELECTED_OPP_PIECE.getPos().equals(meModel.getPos())){
				GlobalController.SELECTION_TOGGLE = false;
				GlobalController.SELECTED_OPP_PIECE = null;
				GlobalController.boardView.unselectAllSquares();
			}
		}
		else{
			GlobalController.SELECTION_TOGGLE = true;
			meSqr.setHexColor(StaticColors.SQUARE_SELECTION_RED);
			var moves: MoveCollection = meModel.getPossibleMoves();
			for(var eachMoveIdx in moves.getMoves()){
				var eachMove: Move = moves.getMoves()[eachMoveIdx];
				var possibleSqr: Square = GlobalController.boardView.getSquareAtPos(eachMove.getDest().getX(), eachMove.getDest().getY());
				possibleSqr.setHexColor(StaticColors.SQUARE_SELECTION_RED);
			}
			GlobalController.SELECTED_OPP_PIECE = meModel;
		}
	}
	if(changeFlag){
		GlobalController.update();
		GlobalController.changeState(State.BLACKS_TURN);
	}
	else{
		GlobalController.update();
	}
}
